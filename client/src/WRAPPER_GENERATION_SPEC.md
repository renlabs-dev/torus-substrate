# Storage Wrapper Generation Specification

## Overview

Generate ergonomic wrapper functions for Substrate storage items from subxt-generated API code. The system parses the raw `api.rs` file and generates clean, typed wrapper functions that handle key decoding and provide intuitive access patterns.

## Architecture

```
api.rs (subxt) → Parser → StorageItem[] → CodeGen → wrappers.rs
```

## Core Components

### 1. Storage Pattern Detection

**Input**: `api.rs` file generated by subxt codegen
**Output**: Structured storage metadata

#### Pattern Identification Rules

```rust
#[derive(Debug, Clone)]
pub enum StoragePattern {
    Value {
        name: String,
        pallet: String,
        return_type: String,
    },
    Map {
        name: String,
        pallet: String,
        key_type: String,
        return_type: String,
    },
    DoubleMap {
        name: String,
        pallet: String,
        key1_type: String,
        key2_type: String,
        return_type: String,
    },
    NMap {
        name: String,
        pallet: String,
        key_types: Vec<String>,
        return_type: String,
    },
}
```

**Detection Logic**:
- **Storage Value**: Method exists without `_iter` counterpart, takes no parameters
- **Storage Map**: Method pair `{name}(_0)` and `{name}_iter()` exists
- **Storage Double Map**: Method takes 2 parameters + `_iter` variant
- **Storage N Map**: Method takes N parameters (N > 2) + `_iter` variant

### 2. Type Resolution

Extract types from `pub mod types` sections:

```rust
// From: pub mod proposals { pub type Proposals = ...; pub type Param0 = ...; }
// Extract: return_type="Proposals", key_type="Param0"
```

### 3. Code Generation Templates

#### Storage Value Template
```rust
pub async fn get_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<{return_type}, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}()).await?;
    Ok(result.unwrap_or_default())
}
```

#### Storage Map Template
```rust
pub async fn get_{storage_name}_by_{key_name}(
    client: &OnlineClient<PolkadotConfig>,
    {key_param}: {key_type},
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key_param})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<HashMap<{key_type}, {return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = HashMap::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok(key) = {key_type}::decode(&mut &kv.key_bytes[32..]) {
            result.insert(key, kv.value);
        }
    }
    Ok(result)
}
```

#### Storage Double Map Template
```rust
pub async fn get_{storage_name}_by_{key1_name}_by_{key2_name}(
    client: &OnlineClient<PolkadotConfig>,
    {key1_param}: {key1_type},
    {key2_param}: {key2_type},
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key1_param}, {key2_param})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<HashMap<{key1_type}, HashMap<{key2_type}, {return_type}>>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = HashMap::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok((key1, key2)) = <({key1_type}, {key2_type})>::decode(&mut &kv.key_bytes[32..]) {
            result.entry(key1).or_insert_with(HashMap::new).insert(key2, kv.value);
        }
    }
    Ok(result)
}
```

#### Storage N Map Template
```rust
pub async fn get_{storage_name}_by_{key_names}(
    client: &OnlineClient<PolkadotConfig>,
    {key_params}: ({key_types}),
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key_args})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<Vec<({key_types}, {return_type})>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = Vec::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok(keys) = <({key_types})>::decode(&mut &kv.key_bytes[32..]) {
            result.push((keys, kv.value));
        }
    }
    Ok(result)
}
```

## Implementation

### Parser Module (`src/parser.rs`)

```rust
use syn::{parse_file, Item, ItemMod, ItemFn, FnArg};
use std::collections::HashMap;

pub struct StorageParser;

impl StorageParser {
    pub fn parse_api_file(content: &str) -> Result<Vec<StoragePattern>, ParseError> {
        let syntax_tree = parse_file(content)?;
        let mut patterns = Vec::new();
        
        for item in syntax_tree.items {
            if let Item::Mod(api_mod) = item {
                if api_mod.ident == "api" {
                    patterns.extend(Self::parse_api_module(&api_mod)?);
                }
            }
        }
        
        Ok(patterns)
    }
    
    fn parse_api_module(api_mod: &ItemMod) -> Result<Vec<StoragePattern>, ParseError> {
        // Walk through pallet modules, extract storage patterns
    }
    
    fn analyze_storage_methods(storage_mod: &ItemMod) -> Vec<StoragePattern> {
        // Group methods by name, analyze parameter counts, detect patterns
    }
}
```

### Code Generator Module (`src/codegen.rs`)

```rust
use quote::quote;
use proc_macro2::TokenStream;

pub struct WrapperGenerator;

impl WrapperGenerator {
    pub fn generate_wrappers(patterns: &[StoragePattern]) -> TokenStream {
        let functions: Vec<TokenStream> = patterns
            .iter()
            .flat_map(|pattern| Self::generate_pattern_wrappers(pattern))
            .collect();
            
        quote! {
            use std::collections::HashMap;
            use subxt::{OnlineClient, PolkadotConfig};
            use subxt::ext::subxt_core::utils::AccountId32;
            use codec::Decode;
            use crate::interfaces::mainnet::api;
            
            #(#functions)*
        }
    }
    
    fn generate_pattern_wrappers(pattern: &StoragePattern) -> Vec<TokenStream> {
        match pattern {
            StoragePattern::Value { .. } => vec![Self::generate_value_wrapper(pattern)],
            StoragePattern::Map { .. } => vec![
                Self::generate_map_getter(pattern),
                Self::generate_map_query(pattern),
            ],
            // ... other patterns
        }
    }
}
```

### Build Integration (`build.rs`)

```rust
use std::env;
use std::path::Path;

fn main() {
    let api_path = "src/interfaces/mainnet.rs"; // or generated api.rs
    let output_path = "src/generated_wrappers.rs";
    
    if Path::new(api_path).exists() {
        let content = std::fs::read_to_string(api_path).unwrap();
        let patterns = parser::StorageParser::parse_api_file(&content).unwrap();
        let wrappers = codegen::WrapperGenerator::generate_wrappers(&patterns);
        
        std::fs::write(output_path, wrappers.to_string()).unwrap();
    }
    
    println!("cargo:rerun-if-changed={}", api_path);
}
```

## Usage

```rust
// Generated wrappers usage
use crate::generated_wrappers::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = OnlineClient::<PolkadotConfig>::from_url("ws://127.0.0.1:9944").await?;
    
    // Storage Value
    let total_stake = get_total_stake(&client).await?;
    
    // Storage Map
    let agent = get_agents_by_account_id(&client, account_id).await?;
    let all_agents = query_map_agents(&client).await?;
    
    // Storage Double Map  
    let staked_amount = get_staked_by_by_agent_by_staker(&client, agent, staker).await?;
    let all_stakes = query_map_staked_by(&client).await?;
    
    // Storage N Map
    let accumulated = get_accumulated_stream_amounts_by_account_by_stream_by_permission(
        &client, account, stream_id, permission_id
    ).await?;
    let all_accumulated = query_map_accumulated_stream_amounts(&client).await?;
    
    Ok(())
}
```

## File Structure

```
utils/
│   ├── parser.rs           # Parse api.rs, extract storage patterns
│   ├── codegen.rs          # Generate wrapper code
│   ├── generated_wrappers.rs  # Generated output (gitignored)
│   └── lib.rs             # Re-export generated wrappers
├── build.rs               # Build-time generation
└── Cargo.toml            # Dependencies: syn, quote, proc-macro2
```

## Dependencies

```toml
[build-dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"

[dependencies]
subxt = "0.37"
codec = "3.6"
tokio = { version = "1.0", features = ["full"] }
```

## Naming Conventions

- **Storage Values**: `get_{storage_name}()`
- **Storage Maps**: `get_{storage_name}_by_{key_name}()`, `query_map_{storage_name}()`
- **Storage Double Maps**: `get_{storage_name}_by_{key1_name}_by_{key2_name}()`, `query_map_{storage_name}()`
- **Storage N Maps**: `get_{storage_name}_by_{key1}_by_{key2}_by_{keyN}()`, `query_map_{storage_name}()`

Type names are converted from PascalCase to snake_case for parameter names (e.g., `AccountId32` → `account_id`, `ProposalId` → `proposal_id`). 