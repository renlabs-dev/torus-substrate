# Storage Wrapper Generation Specification

## Overview

Generate ergonomic wrapper functions for Substrate storage items from subxt-generated API code. The system parses interface files (`mainnet.rs` or `testnet.rs`) and generates clean, typed wrapper functions that handle key decoding and provide intuitive access patterns.

## Architecture

```
interfaces/{mainnet|testnet}.rs → Parser → StorageItem[] → CodeGen → generated_wrappers.rs
```

## Command-Based Generation

### Usage

```bash
# Generate wrappers from mainnet interface
cargo run --bin generate-wrappers -- --source mainnet --output src/generated_wrappers.rs

# Generate wrappers from testnet interface  
cargo run --bin generate-wrappers -- --source testnet --output src/generated_wrappers.rs

# Short form
cargo run --bin generate-wrappers -- -s mainnet -o src/generated_wrappers.rs
```

### Benefits

- ✅ **No build overhead**: Generate only when needed
- ✅ **Clear provenance**: Users can see exactly what interfaces generated the code
- ✅ **Easy debugging**: Generated code is inspectable and can be committed
- ✅ **IDE friendly**: No build-time code changes that confuse language servers
- ✅ **Explicit control**: Developers choose when to regenerate

## Core Components

### 1. Storage Pattern Detection

**Input**: `api.rs` file generated by subxt codegen
**Output**: Structured storage metadata

#### Pattern Identification Rules

```rust
#[derive(Debug, Clone)]
pub enum StoragePattern {
    Value {
        name: String,
        pallet: String,
        return_type: String,
    },
    Map {
        name: String,
        pallet: String,
        key_type: String,
        return_type: String,
    },
    DoubleMap {
        name: String,
        pallet: String,
        key1_type: String,
        key2_type: String,
        return_type: String,
    },
    NMap {
        name: String,
        pallet: String,
        key_types: Vec<String>,
        return_type: String,
    },
}
```

**Detection Logic**:
- **Storage Value**: Method exists without `_iter` counterpart, takes no parameters
- **Storage Map**: Method pair `{name}(_0)` and `{name}_iter()` exists
- **Storage Double Map**: Method takes 2 parameters + `_iter` variant
- **Storage N Map**: Method takes N parameters (N > 2) + `_iter` variant

### 2. Type Resolution

Extract types from `pub mod types` sections:

```rust
// From: pub mod proposals { pub type Proposals = ...; pub type Param0 = ...; }
// Extract: return_type="Proposals", key_type="Param0"
```

### 3. Code Generation Templates

#### Storage Value Template
```rust
pub async fn get_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<{return_type}, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}()).await?;
    Ok(result.unwrap_or_default())
}
```

#### Storage Map Template
```rust
pub async fn get_{storage_name}_by_{key_name}(
    client: &OnlineClient<PolkadotConfig>,
    {key_param}: {key_type},
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key_param})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<HashMap<{key_type}, {return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = HashMap::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok(key) = {key_type}::decode(&mut &kv.key_bytes[32..]) {
            result.insert(key, kv.value);
        }
    }
    Ok(result)
}
```

#### Storage Double Map Template
```rust
pub async fn get_{storage_name}_by_{key1_name}_by_{key2_name}(
    client: &OnlineClient<PolkadotConfig>,
    {key1_param}: {key1_type},
    {key2_param}: {key2_type},
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key1_param}, {key2_param})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<HashMap<{key1_type}, HashMap<{key2_type}, {return_type}>>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = HashMap::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok((key1, key2)) = <({key1_type}, {key2_type})>::decode(&mut &kv.key_bytes[32..]) {
            result.entry(key1).or_insert_with(HashMap::new).insert(key2, kv.value);
        }
    }
    Ok(result)
}
```

#### Storage N Map Template
```rust
pub async fn get_{storage_name}_by_{key_names}(
    client: &OnlineClient<PolkadotConfig>,
    {key_params}: ({key_types}),
) -> Result<Option<{return_type}>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let result = storage.fetch(&api::storage().{pallet}().{storage_name}({key_args})).await?;
    Ok(result)
}

pub async fn query_map_{storage_name}(
    client: &OnlineClient<PolkadotConfig>,
) -> Result<Vec<({key_types}, {return_type})>, Box<dyn std::error::Error>> {
    let storage = client.storage().at_latest().await?;
    let mut result = Vec::new();
    let mut iter = storage.iter(api::storage().{pallet}().{storage_name}_iter()).await?;
    
    while let Some(Ok(kv)) = iter.next().await {
        if let Ok(keys) = <({key_types})>::decode(&mut &kv.key_bytes[32..]) {
            result.push((keys, kv.value));
        }
    }
    Ok(result)
}
```

## Implementation

### Command-Line Tool (`src/bin/generate_wrappers.rs`)

```rust
use clap::Parser;
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "generate-wrappers")]
#[command(about = "Generate storage wrapper functions from subxt interfaces")]
struct Args {
    /// Source interface to parse (mainnet or testnet)
    #[arg(short, long, value_enum)]
    source: InterfaceSource,
    
    /// Output file path
    #[arg(short, long)]
    output: PathBuf,
    
    /// Force overwrite existing output file
    #[arg(short, long)]
    force: bool,
}

#[derive(clap::ValueEnum, Clone)]
enum InterfaceSource {
    Mainnet,
    Testnet,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    
    let interface_path = match args.source {
        InterfaceSource::Mainnet => "src/interfaces/mainnet.rs",
        InterfaceSource::Testnet => "src/interfaces/testnet.rs",
    };
    
    if !std::path::Path::new(interface_path).exists() {
        eprintln!("Error: Interface file not found: {}", interface_path);
        std::process::exit(1);
    }
    
    if args.output.exists() && !args.force {
        eprintln!("Error: Output file already exists: {:?}", args.output);
        eprintln!("Use --force to overwrite");
        std::process::exit(1);
    }
    
    println!("Parsing interface: {}", interface_path);
    let content = std::fs::read_to_string(interface_path)?;
    let patterns = parser::StorageParser::parse_api_file(&content)?;
    
    println!("Found {} storage patterns", patterns.len());
    let wrappers = codegen::WrapperGenerator::generate_wrappers(&patterns, args.source)?;
    
    std::fs::write(&args.output, wrappers)?;
    println!("Generated wrappers: {:?}", args.output);
    
    Ok(())
}
```

### Parser Module (`src/utils/parser.rs`)

```rust
use syn::{parse_file, Item, ItemMod, ItemFn, FnArg};
use std::collections::HashMap;

pub struct StorageParser;

impl StorageParser {
    pub fn parse_api_file(content: &str) -> Result<Vec<StoragePattern>, ParseError> {
        let syntax_tree = parse_file(content)?;
        let mut patterns = Vec::new();
        
        for item in syntax_tree.items {
            if let Item::Mod(api_mod) = item {
                if api_mod.ident == "api" {
                    patterns.extend(Self::parse_api_module(&api_mod)?);
                }
            }
        }
        
        Ok(patterns)
    }
    
    fn parse_api_module(api_mod: &ItemMod) -> Result<Vec<StoragePattern>, ParseError> {
        // Walk through pallet modules, extract storage patterns
    }
    
    fn analyze_storage_methods(storage_mod: &ItemMod) -> Vec<StoragePattern> {
        // Group methods by name, analyze parameter counts, detect patterns
    }
}
```

### Code Generator Module (`src/utils/codegen.rs`)

```rust
use quote::quote;
use proc_macro2::TokenStream;

pub struct WrapperGenerator;

impl WrapperGenerator {
    pub fn generate_wrappers(
        patterns: &[StoragePattern], 
        source: InterfaceSource
    ) -> Result<String, Box<dyn std::error::Error>> {
        let import_path = match source {
            InterfaceSource::Mainnet => "crate::interfaces::mainnet::api",
            InterfaceSource::Testnet => "crate::interfaces::testnet::api",
        };
        
        let functions: Vec<TokenStream> = patterns
            .iter()
            .flat_map(|pattern| Self::generate_pattern_wrappers(pattern))
            .collect();
            
        let output = quote! {
            //! Generated storage wrappers
            //! 
            //! This file was auto-generated from: #interface_path
            //! Do not edit manually - regenerate using:
            //! `cargo run --bin generate-wrappers -- --source #source_name`
            
            use std::collections::HashMap;
            use subxt::{OnlineClient, PolkadotConfig};
            use subxt::ext::subxt_core::utils::AccountId32;
            use codec::Decode;
            use #import_path as api;
            
            #(#functions)*
        };
        
        Ok(output.to_string())
    }
    
    fn generate_pattern_wrappers(pattern: &StoragePattern) -> Vec<TokenStream> {
        match pattern {
            StoragePattern::Value { .. } => vec![Self::generate_value_wrapper(pattern)],
            StoragePattern::Map { .. } => vec![
                Self::generate_map_getter(pattern),
                Self::generate_map_query(pattern),
            ],
            // ... other patterns
        }
    }
}
```

## Usage
```rust
// Include generated wrappers in your module
mod generated_wrappers;
use generated_wrappers::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = OnlineClient::<PolkadotConfig>::from_url("ws://127.0.0.1:9944").await?;
    
    // Storage Value
    let total_stake = get_total_stake(&client).await?;
    
    // Storage Map
    let agent = get_agents_by_account_id(&client, account_id).await?;
    let all_agents = query_map_agents(&client).await?;
    
    // Storage Double Map  
    let staked_amount = get_staked_by_by_agent_by_staker(&client, agent, staker).await?;
    let all_stakes = query_map_staked_by(&client).await?;
    
    // Storage N Map
    let accumulated = get_accumulated_stream_amounts_by_account_by_stream_by_permission(
        &client, account, stream_id, permission_id
    ).await?;
    let all_accumulated = query_map_accumulated_stream_amounts(&client).await?;
    
    Ok(())
}
```

## File Structure

```
src/
├── bin/
│   └── generate_wrappers.rs    # Command-line tool
├── utils/
│   ├── parser.rs              # Parse interface files, extract storage patterns
│   ├── codegen.rs             # Generate wrapper code
│   └── mod.rs                 # Module declarations
├── interfaces/
│   ├── mainnet.rs             # Mainnet interface (input)
│   └── testnet.rs             # Testnet interface (input)  
├── generated_wrappers.rs      # Generated output (committed to git)
└── lib.rs                     # Include generated wrappers
```

## Dependencies

```toml
[dependencies]
subxt = "0.37"
codec = "3.6"
tokio = { version = "1.0", features = ["full"] }

[[bin]]
name = "generate-wrappers"
path = "src/bin/generate_wrappers.rs"

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
clap = { version = "4.0", features = ["derive"] }
```

## Development Workflow

1. **Initial Generation**:
   ```bash
   cargo run --bin generate-wrappers -- --source mainnet --output src/generated_wrappers.rs
   ```

2. **After Interface Updates**:
   ```bash
   # Regenerate from updated interface
   cargo run --bin generate-wrappers -- --source mainnet --output src/generated_wrappers.rs --force
   
   # Review changes
   git diff src/generated_wrappers.rs
   
   # Commit both interface and generated wrapper changes
   git add src/interfaces/mainnet.rs src/generated_wrappers.rs
   git commit -m "Update storage interfaces and regenerate wrappers"
   ```

3. **CI Verification** (optional):
   ```bash
   # Check if generated code is up-to-date
   cargo run --bin generate-wrappers -- --source mainnet --output /tmp/test_wrappers.rs
   diff src/generated_wrappers.rs /tmp/test_wrappers.rs
   ```

## Naming Conventions

- **Storage Values**: `get_{storage_name}()`
- **Storage Maps**: `get_{storage_name}_by_{key_name}()`, `query_map_{storage_name}()`
- **Storage Double Maps**: `get_{storage_name}_by_{key1_name}_by_{key2_name}()`, `query_map_{storage_name}()`
- **Storage N Maps**: `get_{storage_name}_by_{key1}_by_{key2}_by_{keyN}()`, `query_map_{storage_name}()`

Type names are converted from PascalCase to snake_case for parameter names (e.g., `AccountId32` → `account_id`, `ProposalId` → `proposal_id`).