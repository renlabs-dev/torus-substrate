# SUBXT Generated API Structure Documentation

This document describes the structure of the `api.rs` file generated by SUBXT for parser development. The goal is to identify and extract storage patterns (Storage Values, Storage Maps, Storage Double Maps, Storage N Maps) to generate appropriate wrapper functions.

## Overall File Structure

```
api.rs
├── Module Declaration & Attributes
├── Static Metadata Arrays  
├── Type Aliases
├── API Factory Functions
├── Pallet Modules (per pallet)
│   ├── calls/
│   ├── events/  
│   ├── storage/     <-- **PRIMARY FOCUS FOR PARSER**
│   └── constants/
└── runtime_types/   <-- Type definitions
```

## Top-Level Structure

### 1. Module Declaration
```rust
#[allow(dead_code, unused_imports, non_camel_case_types)]
#[allow(clippy::all)]
#[allow(rustdoc::broken_intra_doc_links)]
pub mod api {
    // ... content
}
```

### 2. Static Arrays
```rust
pub static PALLETS: [&str; N] = ["PalletName1", "PalletName2", ...];
pub static RUNTIME_APIS: [&str; M] = [/* runtime APIs */];
```

### 3. Type Aliases
```rust
pub type DispatchError = runtime_types::sp_runtime::DispatchError;
pub type Event = runtime_types::runtime_name::RuntimeEvent;
pub type Call = runtime_types::runtime_name::RuntimeCall;
pub type Error = runtime_types::runtime_name::RuntimeError;
```

### 4. API Factory Functions
```rust
pub fn constants() -> ConstantsApi { ConstantsApi }
pub fn storage() -> StorageApi { StorageApi }
pub fn tx() -> TransactionApi { TransactionApi }
pub fn apis() -> runtime_apis::RuntimeApi { runtime_apis::RuntimeApi }
pub fn custom() -> CustomValuesApi { CustomValuesApi }
```

## Pallet Module Structure

Each pallet gets its own module named in snake_case. For example: `governance`, `balances`, `system`, etc.

### Pallet Module Components
```rust
pub mod {pallet_name} {
    pub type Error = runtime_types::pallet_{name}::pallet::Error;
    pub type Call = runtime_types::pallet_{name}::pallet::Call;
    
    pub mod calls { /* transaction types */ }
    pub mod events { /* event types */ }
    pub mod storage { /* STORAGE ACCESS PATTERNS */ }
    pub mod constants { /* constants */ }
}
```

## Storage Module Structure (PARSER FOCUS)

The `storage` module is where you'll find all the storage access patterns that need to be parsed.

### Storage Module Layout
```rust
pub mod storage {
    use super::runtime_types;
    
    pub mod types {
        // Type definitions for each storage item
        pub mod {storage_item_name} {
            pub type {StorageItemName} = ReturnType;
            pub type Param0 = KeyType0;  // For maps
            pub type Param1 = KeyType1;  // For double maps
            // ... ParamN for N-maps
        }
    }
    
    pub struct StorageApi;
    impl StorageApi {
        // Storage access methods
    }
}
```

## Storage Patterns to Identify

### 1. Storage Value Pattern
**Characteristics:**
- Single method with no parameters
- No corresponding `_iter` method
- Returns a value directly

```rust
pub fn {storage_name}(
    &self,
) -> ::subxt::ext::subxt_core::storage::address::StaticAddress<
    (),  // <-- Empty key tuple indicates Storage Value
    types::{storage_name}::{StorageName},
    ::subxt::ext::subxt_core::utils::Yes,
    ::subxt::ext::subxt_core::utils::Yes,
    (),
>
```

**Example:**
```rust
pub fn treasury_emission_fee(&self) -> StaticAddress<(), TreasuryEmissionFee, Yes, Yes, ()>
```

**Parser Output Should Generate:**
```rust
fn get_treasury_emission_fee() -> TreasuryEmissionFee
```

### 2. Storage Map Pattern
**Characteristics:**
- Two methods: `{name}(_0)` and `{name}_iter()`
- Parameterized version takes one parameter
- Iter version takes no parameters

```rust
// Iterator method (no parameters)
pub fn {storage_name}_iter(
    &self,
) -> ::subxt::ext::subxt_core::storage::address::StaticAddress<
    (),
    types::{storage_name}::{StorageName},
    (),
    (),
    ::subxt::ext::subxt_core::utils::Yes,
>

// Parameterized method (one parameter)
pub fn {storage_name}(
    &self,
    _0: impl ::core::borrow::Borrow<types::{storage_name}::Param0>,
) -> ::subxt::ext::subxt_core::storage::address::StaticAddress<
    ::subxt::ext::subxt_core::storage::address::StaticStorageKey<
        types::{storage_name}::Param0,
    >,
    types::{storage_name}::{StorageName},
    ::subxt::ext::subxt_core::utils::Yes,
    (),
    (),
>
```

**Example:**
```rust
pub fn proposals_iter(&self) -> StaticAddress<(), Proposals, (), (), Yes>
pub fn proposals(&self, _0: impl Borrow<Param0>) -> StaticAddress<StaticStorageKey<Param0>, Proposals, Yes, (), ()>
```

**Parser Output Should Generate:**
```rust
fn get_proposals_by_id(id: ProposalId) -> Proposal
fn query_map_proposals() -> HashMap<ProposalId, Proposal>
```

### 3. Storage Double Map Pattern
**Characteristics:**
- Two methods: `{name}(_0, _1)` and `{name}_iter()`
- Parameterized version takes two parameters
- Type definitions include `Param0` and `Param1`

```rust
// Iterator method
pub fn {storage_name}_iter(&self) -> StaticAddress<(), ReturnType, (), (), Yes>

// Parameterized method (two parameters)
pub fn {storage_name}(
    &self,
    _0: impl ::core::borrow::Borrow<types::{storage_name}::Param0>,
    _1: impl ::core::borrow::Borrow<types::{storage_name}::Param1>,
) -> StaticAddress<StaticStorageKey<(Param0, Param1)>, ReturnType, Yes, (), ()>
```

**Parser Output Should Generate:**
```rust
fn get_{storage_name}_by_{param0_name}_by_{param1_name}(param0: Param0Type, param1: Param1Type) -> ReturnType
fn query_map_{storage_name}() -> HashMap<Param0Type, HashMap<Param1Type, ReturnType>>
```

### 4. Storage N Map Pattern
**Characteristics:**
- Two methods: `{name}(_0, _1, ..., _N)` and `{name}_iter()`
- Parameterized version takes N parameters
- Type definitions include `Param0` through `ParamN`

```rust
// Iterator method
pub fn {storage_name}_iter(&self) -> StaticAddress<(), ReturnType, (), (), Yes>

// Parameterized method (N parameters)
pub fn {storage_name}(
    &self,
    _0: impl ::core::borrow::Borrow<types::{storage_name}::Param0>,
    _1: impl ::core::borrow::Borrow<types::{storage_name}::Param1>,
    // ... more parameters
) -> StaticAddress<StaticStorageKey<(Param0, Param1, ...)>, ReturnType, Yes, (), ()>
```

**Parser Output Should Generate:**
```rust
fn get_{storage_name}_by_{param0}_by_{param1}_by_{paramN}(p0: Param0, p1: Param1, ..., pN: ParamN) -> ReturnType
fn query_map_{storage_name}() -> HashMap<Param0, HashMap<Param1, HashMap<..., ReturnType>>>
```

## Key Parsing Rules

### 1. Storage Type Identification
- **Storage Value**: Method name doesn't end with `_iter` AND no corresponding `{name}_iter` method exists
- **Storage Map**: Method pair exists: `{name}()` and `{name}_iter()`
- **Storage Double Map**: Method takes 2 parameters + has `_iter` variant
- **Storage N Map**: Method takes N parameters (N > 2) + has `_iter` variant

### 2. Type Information Extraction
Look in `pub mod types` for each storage item:
```rust
pub mod {storage_item_name} {
    pub type {StorageItemName} = ActualReturnType;
    pub type Param0 = FirstKeyType;    // Map key / First double map key
    pub type Param1 = SecondKeyType;   // Second double map key
    // ... ParamN for N-maps
}
```

### 3. Parameter Name Generation
- Extract parameter names from type paths
- Convert `AccountId32` → `account_id`
- Convert `ProposalId` → `proposal_id`  
- Convert `StreamId` → `stream_id`
- Use standard snake_case conventions

### 4. Method Name Generation
```rust
// Storage Value
"get_{storage_name}" → "get_treasury_emission_fee"

// Storage Map  
"get_{storage_name}_by_{key_name}" → "get_proposals_by_proposal_id"
"query_map_{storage_name}" → "query_map_proposals"

// Storage Double Map
"get_{storage_name}_by_{key1_name}_by_{key2_name}" → "get_staked_by_by_agent_by_staker"
"query_map_{storage_name}" → "query_map_staked_by"

// Storage N Map
"get_{storage_name}_by_{key1}_by_{key2}_by_{keyN}" → "get_accumulated_amounts_by_account_by_stream_by_permission"
```

## Parser Implementation Strategy

### 1. Parse Module Structure
1. Find `pub mod {pallet_name}`
2. Navigate to `{pallet_name}::storage`
3. Extract `StorageApi` implementation

### 2. Method Analysis
1. Collect all public methods in `StorageApi`
2. Group methods by base name (methods ending with `_iter` are grouped with their non-`_iter` counterpart)
3. Count parameters to determine storage type

### 3. Type Resolution
1. For each storage method, look up the corresponding entry in `pub mod types`
2. Extract return type and parameter types
3. Resolve full type paths from `runtime_types`

### 4. Code Generation
1. Generate appropriate wrapper functions based on storage pattern
2. Handle type conversions and imports
3. Generate both individual accessors and bulk query methods

## Example Complete Analysis

For this storage method:
```rust
pub fn proposals(&self, _0: impl Borrow<types::proposals::Param0>) 
    -> StaticAddress<StaticStorageKey<types::proposals::Param0>, types::proposals::Proposals, Yes, (), ()>
pub fn proposals_iter(&self) 
    -> StaticAddress<(), types::proposals::Proposals, (), (), Yes>
```

With these types:
```rust
pub mod proposals {
    pub type Proposals = runtime_types::pallet_governance::proposal::Proposal;
    pub type Param0 = ::core::primitive::u64;
}
```

**Parser should generate:**
```rust
fn get_proposals_by_id(proposal_id: u64) -> Proposal
fn query_map_proposals() -> HashMap<u64, Proposal>
```

This structure provides a comprehensive foundation for parsing the SUBXT-generated API and extracting the storage patterns you need for your wrapper generation. 